
网络协议

网络协议核心

	是什么：
		
	为什么使用：
		
	基本原理：
		TCP / IP 四层参考模型
				链路层、网络层、传输层、应用层。
		
		OSI 七层参考模型
			物理层、链路层、网络层、传输层、会话层、表示层、应用层。
		
	怎么使用：






	TCP / IP 四层参考模型：
		链路层、网络层、传输层、应用层。
		应用层：
			负责处理特定的应用程序细节。
			 (FTP，Telnet，Emai，DNS，SMTP，HTTP 等) 
		传输层 (运输层) ：
			主要为两台主机上的应用提供端到端的通信；
			 (TCP 和 UDP) 
		网络层 (网际互联层 / 互联网层) ：
			处理分组在网络中的活动，比如分组的选路；
			 (IP，ICMP，IGMP) 
		链路层 (数据链路层 / 网络接口层) ：
			包括操作系统中的设备驱动程序、计算机中对应的网络接口卡；

	OSI 七层参考模型：
		物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。
			会话层：上层数据
			传输层：TCP 头；段
			网络层：IP 头；帧
				数据链路层：MAC 头 + FCS	/ LLC 头 + FCS；比特流
				
	端口：一个 IP 地址可以有 65536 个端口；定义端口号，建议使用 10000 以上的。

	TCP 和 UDP 的区别：
		TCP (Transmission Control Protocol，传输控制协议) ：
			面向连接 (必须经历三次握手建立连接，四次握手释放连接) 、
			数据安全 (保证数据正确性和数据顺序) 、
			用于传输大量数据 (流模式) 、
			速度慢，
			建立连接需要的开销多 (时间、系统资源) 。
			强调服务端和客户端。
		UDP (User Datagram Protocol，用户数据报协议) ：
			面向非连接、
			传输不可靠 (丢包或数据丢失) 、
			用于传输少量数据 (数据报包模式) 、
			速度快。
			强调发送端和接收端。


HTTP

	超文本传输协议 (HTTP) 的统一资源定位符将从因特网获取信息的五个基本元素包括在一个简单的地址中：

		传送协议。
		服务器。
		端口号。 (以数字方式表示，若为 HTTP 的默认值“:80”可省略) 
		路径。 (以“/”字符区别路径中的每一个目录名称) 
		查询。 (GET 模式的窗体参数，以“?”字符为起点，每个参数以“&”隔开，再以“=”分开参数名称与数据，通常以 UTF8 的 URL 编码，避开字符冲突的问题) 
			典型的统一资源定位符看上去是这样的：
				(带方括号 [] 的为可选项)：
					protocol :// hostname[:port] / path / [;parameters][?query]#fragment

	request body

		User-Agent: Fiddler
		Host: localhost:1455 
		Content-Type: application/x-www-form-urlencoded;<span style="font-family: Arial, Helvetica, sans-serif;">charset=utf-8 </span>
		Content-Length: 38

		name1=valule1&name2=value2

		HTTP/1.1 200 OK
		Connection: keep-alive
		X-XSS-Protection: 1; mode=block
		X-Content-Type-Options: nosniff
		Content-Type: application/json;charset=UTF-8
		Content-Length: 492
		Date: Tue, 10 Jul 2018 09:18:40 GMT


	HTTP 返回码详解
		常见：
			200  服务器成功返回网页 
			404  请求的网页不存在 
			503  服务不可用
		1xx（临时响应）表示临时响应并需要请求者继续执行操作的状态代码。
			100（继续）请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。  
			101（切换协议）请求者已要求服务器切换协议，服务器已确认并准备切换。
		2xx （成功）表示成功处理了请求的状态代码。
			200（成功）服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。
			201（已创建）请求成功并且服务器创建了新的资源。
			202（已接受） 服务器已接受请求，但尚未处理。
			203（非授权信息）服务器已成功处理了请求，但返回的信息可能来自另一来源。
			204（无内容）服务器成功处理了请求，但没有返回任何内容。
			205（重置内容）服务器成功处理了请求，但没有返回任何内容。
			206（部分内容）服务器成功处理了部分 GET 请求。
		3xx （重定向）表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。
			300（多种选择）针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。
			301（永久移动）请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。
			302（临时移动）服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。
			303（查看其他位置）请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。
			304（未修改）自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。
			305（使用代理）请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。
			307（临时重定向）服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。
		4xx（请求错误）这些状态代码表示请求可能出错，妨碍了服务器的处理。
			400（错误请求）服务器不理解请求的语法。
			401（未授权）请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。
			403（禁止）服务器拒绝请求。
			404（未找到）服务器找不到请求的网页。
			405（方法禁用）禁用请求中指定的方法。
			406（不接受）无法使用请求的内容特性响应请求的网页。
			407（需要代理授权）此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。
			408（请求超时）服务器等候请求时发生超时。
			409（冲突）服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。
			410（已删除）如果请求的资源已永久删除，服务器就会返回此响应。
			411（需要有效长度）服务器不接受不含有效内容长度标头字段的请求。
			412（未满足前提条件）服务器未满足请求者在请求中设置的其中一个前提条件。
			413（请求实体过大）服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。
			414（请求的 URI 过长）请求的 URI（通常为网址）过长，服务器无法处理。
			415（不支持的媒体类型）请求的格式不受请求页面的支持。
			416（请求范围不符合要求）如果页面无法提供请求的范围，则服务器会返回此状态代码。
			417（未满足期望值）服务器未满足”期望”请求标头字段的要求。
		5xx（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。
				这些错误可能是服务器本身的错误，而不是请求出错。
			500（服务器内部错误）服务器遇到错误，无法完成请求。
			501（尚未实施）服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。
			502（错误网关）服务器作为网关或代理，从上游服务器收到无效响应。
			503（服务不可用）服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。
			504（网关超时）服务器作为网关或代理，但是没有及时从上游服务器收到请求。
			505（HTTP 版本不受支持）服务器不支持请求中所用的 HTTP 协议版本。
		RFC 6585 最近刚刚发布，该文档描述了 4 个新的 HTTP 状态码。
				HTTP 协议还在变化？是的，HTTP 协议一直在演变，
				新的状态码对于开发 REST 服务或者说是基于 HTTP 的服务非常有用，
				下面我们为你详细介绍这四个新的状态码以及是否应该使用。
			428 Precondition Required (要求先决条件)
				先决条件是客户端发送 HTTP 请求时，如果想要请求能成功必须满足一些预设的条件。
				一个好的例子就是 If-None-Match 头，经常在 GET 请求中使用，如果指定了 If-None-Match ，那么客户端只在响应中的 ETag 改变后才会重新接收回应。
				先决条件的另外一个例子就是 If-Match 头，这个一般用在 PUT 请求上用于指示只更新没被改变的资源，这在多个客户端使用 HTTP 服务时用来防止彼此间不会覆盖相同内容。
				当服务器端使用 428 Precondition Required 状态码时，表示客户端必须发送上述的请求头才能执行请求，这个方法为服务器提供一种有效的方法来阻止 'lost update' 问题。
			429 Too Many Requests (太多请求)
				当你需要限制客户端请求某个服务数量时，该状态码就很有用，也就是请求速度限制。
				在此之前，有一些类似的状态码，例如 '509 Bandwidth Limit Exceeded'. Twitter 使用 420 （这不是HTTP定义的状态码）
				如果你希望限制客户端对服务的请求数，可使用 429 状态码，同时包含一个 Retry-After 响应头用于告诉客户端多长时间后可以再次请求服务。
			431 Request Header Fields Too Large (请求头字段太大)
				某些情况下，客户端发送 HTTP 请求头会变得很大，那么服务器可发送 431 Request Header Fields Too Large 来指明该问题。
			511 Network Authentication Required (要求网络认证)
				对我来说这个状态码很有趣，如果你在开发一个 HTTP 服务器，你不一定需要处理该状态码，但如果你在编写 HTTP 客户端，那这个状态码就非常重要。
				如果你频繁使用笔记本和智能手机，你可能会注意到大量的公用 WIFI 服务要求你必须接受一些协议或者必须登录后才能使用。这是通过拦截HTTP流量，当用户试图访问网络返回一个重定向和登录，这很讨厌，但是实际情况就是这样的。使用这些“拦截”客户端，会有一些讨厌的副作用。在 RFC 中有提到这两个的例子：
					如果你在登录WIFI前访问某个网站，网络设备将会拦截首个请求，
						这些设备往往也有自己的网站图标 ‘favicon.ico'。
						登录后您会发现，有一段时间内你访问的网站图标一直是WIFI登录网站的图标。
					如果客户端使用HTTP请求来查找文档（可能是JSON），网络将会响应一个登录页，
						这样你的客户端就会解析错误并导致客户端运行异常，在现实中这种问题非常常见。
				因此 511 状态码的提出就是为了解决这个问题。
				如果你正在编写 HTTP 的客户端，你最好还是检查 511 状态码以确认是否需要认证后才能访问。

	
Socket：

	Java socket 编程：
		服务器端，
			首先是服务器初始化 Socket，
			然后是与端口进行绑定 (blind()),
			端口创建 ServerSocket 进行监听 (listen()),
			然后调用阻塞 (accept()), 等待客户端连接。
			与客户端发生连接后，会进行相关的读写操作 (read(),write())，
			最后调用 close() 关闭连接。



SOAP：
	Simple Object Access Protocol：简单对象访问协议。
	一种标准化的通讯规范，主要用于 Web 服务 (web service) 中。
	这里之所以说是简单，是因为它是基于已经广泛使用的两个协议：HTTP 和 XML，
	所以业界把这种技术称为“它是第一个没有发明任何新技术的技术"。


RESTful：
	HTTP 接口开发，也就是我们常说的 RESTful 风格的服务接口









