
正则表达式


常用正则：
	
	查找文档注释：/\*{1,2}[\s\S]*?\*/
	查找单行注释：//{1,2}[\s\S]*?\n
	
	notepad++ 中英文自动空格：
		([A-Za-z0-9\.,!@#?\)\]\}\+])([\x{4e00}-\x{9fa5}])	$1 $2
		([\x{4e00}-\x{9fa5}])([A-Za-z0-9\(\[\{@#])			$1 $2
		([。，！？〔〕 () 《》“”]) +						$1
		 +([。，！？〔〕 () 《》“”]) 						$1
		 +
	
	中英文自动空格：
		([\u4e00-\u9fa5])([A-Za-z]+)([\u4e00-\u9fa5])		$1 $2 $3
		([A-Za-z])([\u4e00-\u9fa5])							$1 $2
		([\u4e00-\u9fa5])([A-Za-z])							$1 $2
		
		
		
		
		
		
		
基础
	元字符：
		( [ { \ ^ $ | ) ? * + .
		如果要在正则中匹配这些元字符，需要加转义符 \
		
	特殊字符：
		\t：制表符
		\v：垂直制表符
		\n：换行符 
		\r：回车符
		\f：换页符
		\a：alert字符
		\e：escape字符
		\0：空字符

	字符类：
		简单类：
			[]这个整体对应一个字符；
		负向类
			[]中首字符设为^，匹配不能为括号里面的字符；
		范围类
			匹配的东西过多且类型又相同，全部输入太麻烦，用[]，同类字符之间加一个-即可
		组合类
			[]匹配不同类型的单个字符
		预定义类
			预定义的一些常用字符类，本质上是[]的马甲：
				. ：匹配除了换行和回车之外的任意字符，相当于[^\n\r]
				\d：匹配数字字符，相当于[0-9]
				\D：匹配非数字字符，相当于[^0-9]
				\s：匹配空白字符，相当于[ \t\n\x0B\f\r]
				\S：匹配非空白字符，相当于[^ \t\n\x0B\f\r]
				\w：匹配单词字符(所有的字母)，相当于[a-zA-Z_0-9]
				\W：匹配非单词字符，相当于[^a-zA-Z_0-9]
	
	量词：
		简单量词：
			?：软性量词 出现零次或一次
			*：软性量词 出现零次或多次(任意次)
			+：软性量词 出现一次或多次(至少一次)
			{n}：硬性量词 对应固定n次
			{n,m}：软性量词 至少出现n次但不超过m次
			{n,}：软性量词 至少出现n次(+的升级版)
		
		贪婪量词、非贪婪量词、支配性量词：
			在合法的情况下，正则会尽量地多去匹配字符，这就叫做贪心模式。
			如果我们希望正则尽量少地匹配字符，只要在表示数字的符号后面加上一个?
			(即：问号加在量词的后边，则表示非贪婪模式)。
			组成如下的形式：{n,}?, *?, +?, ??, {m,n}?。
			上面两种模式都有个不断尝试的过程，而支配性量词却只尝试一次，如果不成功就算了
			(javascript不支持该模式！)

	分组：
		[] 方括号：表示范围内选择，
		{} 花括号：表示重复次数，
		() 圆括号：允许重复多个字符。
	
	反向引用：
		反向引用标识正则表达式中的匹配组捕获的子字符串。
		每个反向引用都由一个编号或名称来标识，并通过“\编号”表示法在正则规则中进行引用。
	
	候选
		元字符|相当于正则表达式中的或，有一个候选项满足，就停止其它候选项匹配
	
	非捕获性分组
		不是所有分组都能创建反向引用，有一种特别的分组称之为非捕获性分组，它不会创建反向引用，即可以避免保存括号内的匹配结果。
		反之，就是捕获性分组。
		要创建一个非捕获性分组，只要在分组的左括号的后面紧跟一个问号与冒号就行了((?:pattern))
		
		注意：javascript 不存在命名分组
	
	前瞻
		正向前瞻
			形式：(?=pattern)所谓正向前瞻，意思就是：要匹配的字符串，后面必须紧跟着pattern
		负向前瞻
			形式(?!pattern)和?=恰好相反，要求字符串的后面不能紧跟着某个pattern
		
	边界
		要与字符串合用的特殊字符，前面基本都用到了
			^：开头
			$：结尾
			\b：单词边界([a-zA-Z_0-9]之外的字符)
			\B：非单词边界
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
前面的.*? 是非贪婪匹配的意思，表示找到最小的就可以了

(?=Expression) 顺序环视，
(?=\\() 匹配正括号

	1. 什么是正则表达式的贪婪与非贪婪匹配
		如：String str="abcaxc";
		Patter p="ab*c";
		贪婪匹配:正则表达式一般趋向于最大长度匹配，也就是所谓的贪婪匹配。
		如上面使用模式 p 匹配字符串 str，结果就是匹配到：abcaxc(ab*c)。
		非贪婪匹配：就是匹配到结果就好，就少的匹配字符。
		如上面使用模式 p 匹配字符串 str，结果就是匹配到：abc(ab*c)。

		
	2. 编程中如何区分两种模式
		默认是贪婪模式；在量词后面直接加上一个问号？就是非贪婪模式。
		量词：{m,n}：m 到 n 个
		*：任意多个
		+：一个到多个
		？：0 或一个
		
		.表示除\n 之外的任意字符
		*表示匹配 0-无穷 
		+表示匹配 1-无穷
		(?=Expression) 顺序环视，
		(?=\\() 就是匹配正括号
		懒惰模式正则： 
		src=".*? (?=\\()) "
	
	
	
	
	
	
	
	
	
	
	
	