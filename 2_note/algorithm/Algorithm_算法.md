# Algorithm / 算法

---

## Content / 目录

---

- [一、基础部分](#基础部分)
    - [01、堆排序](#堆排序)
    - [02、双堆法](#双堆法)
    - [03、分治法](#分治法)
    - [04、位图法](#位图法)
    - [05、HashMap 法](#HashMap-法)
    - [06、前缀树法](#前缀树法)
    - [07、查表法](#查表法)
- [二、动态规划](#动态规划)
    - [01、斐波那契数列](#斐波那契数列)
    - [](#)

---

## 方法归类

---

### 堆排序

**堆顶：**

堆是一种非线性结构，可以把堆看作一个数组，也可以被看作一个完全二叉树，通俗来讲堆其实就是利用完全二叉树的结构来维护的一维数组。

**大顶堆**：每个结点的值都大于或等于其左右孩子结点的值。

**小顶堆**：每个结点的值都小于或等于其左右孩子结点的值。

题目描述：

_有 20 个数组，每个数组有 500 个元素，并且有序排列。如何在这 20*500 个数中找出前 500 的数？_

解题思路：

**对于 TopK 问题，最常用的方法是使用堆排序。**

具体过程：

> 首先建立大顶堆，堆的大小为数组的个数，即为 20，把每个数组最大的值存到堆中。
>
> 接着删除堆顶元素，保存到另一个大小为 500 的数组中，然后向大顶堆插入删除的元素所在数组的下一个元素。
>
> 重复上面的步骤，直到删除完第 500 个元素，也即找出了最大的前 500 个数。
>
> 为了在堆中取出一个数据后，能知道它是从哪个数组中取出的，从而可以从这个数组中取下一个值，可以把数组的指针存放到堆中，对这个指针提供比较大小的方法。

解题代码：👉 [HeapSort.java](
https://github.com/bourneo/self-cultivation-of-a-software-engineer/blob/master/2_note/algorithm/code/HeapSort.java
) 👈

### 双堆法

题目描述：

_从 5 亿个数中找出中位数。数据排序后，位置在最中间的数就是中位数。当样本数为奇数时，中位数为 第 (N+1)/2 个数；当样本数为偶数时，中位数为 第 N/2 个数与第 1+N/2 个数的均值。_

解题思路：

如果这道题没有内存大小限制，则可以把所有数读到内存中排序后找出中位数。但是最好的排序算法的时间复杂度都为 O(NlogN)。这里使用其他方法：双堆法。

具体过程：

> 维护两个堆，一个大顶堆，一个小顶堆。大顶堆中最大的数小于等于小顶堆中最小的数；保证这两个堆中的元素个数的差不超过 1。
>
> 若数据总数为偶数，当这两个堆建好之后，中位数就是这两个堆顶元素的平均值。当数据总数为奇数时，根据两个堆的大小，中位数一定在数据多的堆的堆顶。

解题代码：👉 [TwoHeap.java](
https://github.com/bourneo/self-cultivation-of-a-software-engineer/blob/master/2_note/algorithm/code/TwoHeap.java
) 👈

### 分治法

题目描述：

_有个 1GB 大小的文件，文件里每一行是一个词，每个词的大小不超过 16B，内存大小限制是 1MB，要求返回频数最高的 100 个词 (Top 100)。_

解题思路：

**分而治之，进行哈希取余；使用 HashMap 统计频数；求解 最大的 TopN 个，用小顶堆；求解最小的 TopN 个，用大顶堆。**

具体过程：

> 首先遍历大文件，对遍历到的每个词 x，执行 hash(x) % 5000，将结果为 i 的词存放到文件 ai 中。遍历结束后，我们可以得到 5000 个小文件。每个小文件的大小为 200KB
> 左右。如果有的小文件大小仍然超过 1MB，则采用同样的方式继续进行分解。
>
> 接着统计每个小文件中出现频数最高的 100 个词。最简单的方式是使用 HashMap 来实现。其中 key 为词，value 为该词出现的频率。具体方法是：对于遍历到的词 x，如果在 map
> 中不存在，则执行 map.put(x, 1)；若存在，则执行 map.put(x, map.get(x)+1)，将该词频数加 1。
>
> 上面我们统计了每个小文件单词出现的频数。接下来，我们可以通过维护一个小顶堆来找出所有词中出现频数最高的 100 个。具体方法是：依次遍历每个小文件，构建一个小顶堆，堆大小为
> 100。如果遍历到的词的出现次数大于堆顶词的出现次数，则用新词替换堆顶的词，然后重新调整为小顶堆，遍历结束后，小顶堆上的词就是出现频数最高的 100 个词。

### 位图法

**位图：**

用一个或多个 bit 来标记某个元素对应的值，而键就是该元素。采用位作为单位来存储数据，可以大大节省存储空间。

**位图通过位数组来表示某些元素是否存在，它可以用于快速查找，判重，排序等。**

题目描述：

_在 2.5 亿个整数中找出不重复的整数。注意：内存不足以容纳这 2.5 亿个整数。_

解题思路：

**判断数字是否重复的问题，位图法是一种非常高效的方法。对于整数相关的算法的求解，位图法是一种非常实用的算法。**

具体过程：

> 我们用 2 个 bit 来表示各个数字的状态。00 表示这个数字没出现过；01 表示这个数字出现过一次（即为题目所找的不重复整数）；10 表示这个数字出现了多次。
>
> 那么这 232 个整数，总共所需内存为 232*2b=1GB。因此，当可用内存超过 1GB 时，可以采用位图法。
>
> 假设内存满足位图法需求，进行下面的操作：遍历 2.5 亿个整数，查看位图中对应的位，如果是 00，则变为 01，如果是 01 则变为 10，如果是 10 则保持不变。
>
> 遍历结束后，查看位图，把对应位是 01 的整数输出即可。

### HashMap 法

题目描述：

_假设目前有 1000w 个记录（这些查询串的重复度比较高，虽然总数是 1000w，但如果除去重复后，则不超过 300w 个）。请统计最热门的 10 个查询串，要求使用的内存不能超过
1G。（一个查询串的重复度越高，说明查询它的用户越多，也就越热门。）_

解题思路：

虽然字符串总数比较多，但去重后不超过 300w，因此，可以考虑把所有字符串及出现次数保存在一个 HashMap 中，所占用的空间为 300w*(255+4)≈777M（其中，4 表示整数占用的 4
个字节）。由此可见，1G 的内存空间完全够用。

具体过程：

> 首先，遍历字符串，若不在 map 中，直接存入 map，value 记为 1；若在 map 中，则把对应的 value 加 1，这一步时间复杂度 O(N)。
>
> 接着遍历 map，构建一个 10 个元素的小顶堆，若遍历到的字符串的出现次数大于堆顶字符串的出现次数，则进行替换，并将堆调整为小顶堆。
>
> 遍历结束后，堆中 10 个字符串就是出现次数最多的字符串。这一步时间复杂度 O(Nlog10)。

### 前缀树法

**Trie 树 / 前缀树 / 字典树：**

**是一种空间换时间的数据结构，是一种树形结构 (字典树是一种数据结构)，典型用于统计、排序、和保存大量字符串。**

> 前缀树经常被用来统计字符串的出现次数。它的另外一个大的用途是字符串查找，判断是否有重复的字符串等。经常被搜索引擎系统用于文本词频统计。

优点：

> 利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。

题目描述：

_假设目前有 1000w 个记录（这些查询串的重复度比较高，虽然总数是 1000w，但如果除去重复后，则不超过 300w 个）。请统计最热门的 10 个查询串，要求使用的内存不能超过
1G。（一个查询串的重复度越高，说明查询它的用户越多，也就越热门。）_

解题思路：

**如果这些字符串有大量相同前缀，可以考虑使用前缀树来统计字符串出现的次数，树的结点保存字符串出现次数，0 表示没有出现。**

### 查表法

题目描述：

_查询数组中有没有比它前面元素都大，比它后面的元素都小的数，没有打印 -1, 有显示其索引。_

解题思路：

**将一些事先计算好的结果，存储在常量数组中，运行时节省计算开销。**

具体过程：

> 一个数组存从左到右的最大值 max, 另一个数组存从右到左的最小值 min。



---

## 经典算法

---

### LRU 算法 / Least Recently Used / 最久未使用算法

淘汰最旧的缓存，典型的应用场景就是手机上的App使用列表历史。

本质上需要解决的问题是两点：

> 缓存查找性能。
>
> 缓存的增、删、改性能，而且要求缓存有序。

最快的查找必然是哈希表，增、删、改性能最好的是双向链表，所以 LRUCache 的底层数据结构就是哈希表和双链表，结合这两个数据结构的优点解决两个问题。

所以实现 LRU 的数据结构如下：

1. 通过哈希表解决查找性能
2. 通过双链表解决缓存管理性能

### LFU 算法 / Least Frequently Used / 最少使用算法

淘汰使用频率最低的缓存，典型的应用场景是代理的缓存系统。

LFU 策略和 LRU 相比，在淘汰缓存时，多了一个查找维度：频率。

所以查找时，依旧要处理查找频率的问题。缓存的增、删、改性能以及优秀，和 LRU 相同，所以依旧通过双链表来解决。

LFU 策略中，会出现同一频率下的缓存淘汰。淘汰策略可以根据具体应用场景来设计，但是最朴素的就是进行 LRU 淘汰。

所以实现 LRU 的数据结构如下：

1. 通过哈希表解决查找性能。
2. 增加频率维度的哈希表解决频率维度的查找性能。
3. 通过双链表解决缓存管理性能。

### KMP 的 Sunday 算法

Knuth-Morria-Pratt 算法 / 快速模式匹配算法

视频讲解：[容易理解且效率不输 KMP 的 Sunday 算法 | 一学就会还忘不了](https://www.bilibili.com/video/BV1jq4y1K7eY)



---

## 动态规划

---

### 斐波那契数列

题目描述：

_斐波那契数，通常用 F(n) 表示，形成的序列称为斐波那契数列。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。_

```
F(0) = 0，F(1) =  1
F(n) = F(n - 1) + F(n - 2)，其中 n > 1
```

_给你 n ，请计算 F(n) 。_

解题代码：👉 [FibonacciNumber.java](
https://github.com/bourneo/self-cultivation-of-a-software-engineer/blob/master/2_note/algorithm/code/FibonacciNumber.java
) 👈



---

## 常见题

---

### 二叉树的 level 遍历

### 最长子串和

---


---

## 算法题标签

---

### 基本

**数组**

**字符串**

排序

矩阵

模拟

枚举

字符串匹配

桶排序

计数排序

基数排序

### 算法

动态规划

深度优先搜索

贪心

广度优先搜索

**二分查找**

回溯

**递归**

分治

记忆化搜索

归并排序

快速选择

### 基础数据结构

**哈希表**

树

二叉树

栈

堆（优先队列）

图

**链表**

二叉搜索树

单调栈

有序集合

队列

拓扑排序

最短路

单调队列

双向链表

最小生成树

欧拉回路

强连通分量

双连通分量

### 高级数据结构

并查集

字典树

线段树

树状数组

后缀数组

### 技巧

**双指针**

**位运算**

前缀和

计数

滑动窗口

状态压缩

哈希函数

滚动哈希

扫描线

### 数学

数学

几何

博弈

组合数学

数论

随机化

概率与统计

水塘抽样

拒绝采样

### 其他

**数据库**

设计

数据流

交互

脑筋急转弯

迭代器

**多线程**

Shell

---

## 按知识点刷算法题

---

视频讲解：[刷完这70道力扣Leetcode题，你就可以出新手村啦](https://www.bilibili.com/video/BV1Cp4y1a79T)

### 数据结构：

数组 Array：485 / 283 / 27

链表 Linked List：203 / **206**

队列 Queue：933 / 225（用队列实现栈） / 622 / 641

栈 stack：**20** / 496 / 232（用栈实现队列）

哈希表 Hash table：217 / 389 / 496

集合 set：217 / 705（设计）

堆 Heap：**215** / 692

树 & 图

### 算法：

双指针 two pointers：**141** / 344 / 881

二分查找 binary search：704 / 35 / 162 / 74

滑动窗口 sliding window（技巧）：209 / 1456

递归 recursion：509 / **206** / 344 / 687

分治 divide & conquer：**169** / **53**

回溯 backtracking：**22** / **78** / 77 / **46**（全经典）

深度优先搜索 DFS：938 / **78** / **200**

宽度优先搜索 BFS：**200** / 547 / 721

并查集 union find：**200** / 547 / 721

贪心 greedy： 1217 / **55**

记忆化搜索（技巧）：509 / **322**

动态规划 dynamic programming：**322** / 509 / **62** / **121** / **70** / **279** / **221**

拓扑排序 topologic sort：**207** / 210

前缀树 trie：**208** / 720 / 692

---

参考链接：

- [10 道 BAT 大厂海量数据面试题（附题解 + 方法总结）](https://mp.weixin.qq.com/s/rjGqxUvrEqJNlo09GrT1Dw)
- [谈谈堆排序，大顶堆，小顶堆？](https://www.jianshu.com/p/15a29c0ace73)
- [位图算法：什么是 BitMap ](https://www.cnblogs.com/54chensongxia/p/11591979.html)
- [一文搞懂字典树](https://segmentfault.com/a/1190000040801084)
- [两种缓存策略-LRU和LFU实现](https://ganquan.org/2022/01/17/cache-policy-lru-lfu/)
- []()
- []()
- []()

---




















